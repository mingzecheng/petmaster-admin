<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可交互科幻地球仪 - 国家级数据</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', 'Arial', sans-serif; /* 科幻字体回退 */
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
        }
        
        /* HUD / UI 界面 */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* 顶部标题区 */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 2px;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 10px;
            display: inline-block;
        }

        /* 信息面板 */
        #info-panel {
            width: 300px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ffff;
            border-left: 5px solid #00ffff;
            padding: 20px;
            color: #fff;
            transform: translateX(-120%); /* 默认隐藏 */
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }
        #info-panel.active {
            transform: translateX(0);
        }
        .panel-label {
            font-size: 12px;
            color: #00aaaa;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        #country-name {
            font-size: 28px;
            font-weight: bold;
            margin: 0 0 10px 0;
            color: #ffffff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        #coords-display {
            font-family: monospace;
            color: #00ffff;
            font-size: 14px;
        }

        /* 加载指示器 */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .controls {
            pointer-events: auto;
            margin-top: 10px;
        }
        button {
            background: transparent;
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 16px;
            cursor: pointer;
            text-transform: uppercase;
        }
        button:hover {
            background: rgba(0,255,255,0.2);
        }
    </style>
</head>
<body>

    <div id="loader">正在初始化行星数据链接...</div>

    <div id="ui-layer">
        <div class="header">
            <div>
                <h1>PLANETARY SYSTEM // 地球全息图</h1>
                <div style="font-size: 12px; margin-top:5px; opacity:0.7;">
                    状态: 在线 | 交互: 激活
                </div>
            </div>
            <div class="controls">
                <button onclick="resetView()">重置视图</button>
            </div>
        </div>

        <div id="info-panel">
            <div class="panel-label">Selected Target // 目标锁定</div>
            <div id="country-name">Scanning...</div>
            <hr style="border: 0; border-top: 1px solid rgba(0,255,255,0.3); margin: 10px 0;">
            <div class="panel-label">Coordinates // 坐标数据</div>
            <div id="coords-display">LAT: -- | LON: --</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let globeGroup = new THREE.Group(); // 整个地球的容器
        let countriesGroup = new THREE.Group(); // 存放国家线条
        let baseSphere; // 用于点击检测的基础球体
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // 数据相关
        let allCountriesData = []; // 存储GeoJSON原始数据
        let highlightedObj = null; // 当前高亮的对象

        const EARTH_RADIUS = 10;

        // 初始化入口
        init();

        function init() {
            // 1. 场景设置
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.FogExp2(0x020205, 0.02);

            // 2. 相机
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 25);

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. 光照
            const ambientLight = new THREE.AmbientLight(0x444444);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(15, 10, 10);
            scene.add(dirLight);

            // 5. 地球基础球体 (黑色海洋，同时用于射线检测)
            const sphereGeo = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            const sphereMat = new THREE.MeshPhongMaterial({
                color: 0x050505,
                emissive: 0x000000,
                specular: 0x111111,
                shininess: 10,
                transparent: true,
                opacity: 0.95
            });
            baseSphere = new THREE.Mesh(sphereGeo, sphereMat);
            globeGroup.add(baseSphere);

            // 添加内部发光核心 (Sci-Fi感)
            const coreGeo = new THREE.SphereGeometry(EARTH_RADIUS * 0.99, 32, 32);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0x001133 });
            globeGroup.add(new THREE.Mesh(coreGeo, coreMat));

            // 添加大气层光晕
            const atmoGeo = new THREE.SphereGeometry(EARTH_RADIUS * 1.1, 64, 64);
            const atmoMat = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.08,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            globeGroup.add(new THREE.Mesh(atmoGeo, atmoMat));

            globeGroup.add(countriesGroup);
            scene.add(globeGroup);

            // 6. 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 12;
            controls.maxDistance = 60;
            controls.autoRotate = true; // 闲置时自动旋转
            controls.autoRotateSpeed = 0.5;

            // 7. 加载地图数据
            loadGeoJSON();

            // 8. 事件监听
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onMouseDown); // 点击事件

            // 开始渲染
            animate();
        }

        // --- 数据处理与几何体生成 ---

        async function loadGeoJSON() {
            // 使用 GitHub 上的自然地球低分辨率数据 (110m精度)
            const url = 'https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_admin_0_countries.geojson';
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                document.getElementById('loader').style.display = 'none';
                processGeoJSON(data);
            } catch (error) {
                console.error("Failed to load map data", error);
                document.getElementById('loader').innerText = "数据链接失败，请检查网络";
            }
        }

        function processGeoJSON(data) {
            allCountriesData = data.features;

            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x005577, transparent: true, opacity: 0.6 });

            data.features.forEach(feature => {
                const countryName = feature.properties.NAME || feature.properties.name;
                const geometry = feature.geometry;

                if (geometry.type === 'Polygon') {
                    const coords = geometry.coordinates[0];
                    drawCountryBorder(coords, lineMaterial, countryName);
                } else if (geometry.type === 'MultiPolygon') {
                    geometry.coordinates.forEach(polygon => {
                        const coords = polygon[0];
                        drawCountryBorder(coords, lineMaterial, countryName);
                    });
                }
            });
        }

        function drawCountryBorder(coordinates, material, name) {
            const points = [];
            
            coordinates.forEach(coord => {
                // GeoJSON是 [Lon, Lat]
                const lat = coord[1];
                const lon = coord[0];
                const pos = latLonToVector3(lat, lon, EARTH_RADIUS);
                points.push(pos);
            });

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            
            // 将国家名称存入 userData，方便后续点击识别
            // 注意：这里我们绘制的是线，点击判定我们用数学方法，而不是射线击中线
            line.userData = { isBorder: true }; 
            countriesGroup.add(line);
        }

        // --- 坐标转换核心数学 ---

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));

            return new THREE.Vector3(x, y, z);
        }

        // --- 交互逻辑 (核心难点) ---

        function onMouseDown(event) {
            // 停止自动旋转以方便查看
            controls.autoRotate = false;

            // 1. 计算鼠标位置
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 2. 射线检测
            raycaster.setFromCamera(mouse, camera);
            
            // 我们检测与基础球体(baseSphere)的交点
            const intersects = raycaster.intersectObject(baseSphere);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                
                // 3. 将交点转换回地球坐标系的局部坐标
                // (因为地球本身可能被旋转了，我们需要相对于地球的原始坐标)
                // 由于我们旋转的是 globeGroup，我们需要把世界坐标转为 group 的局部坐标
                const localPoint = point.clone().applyMatrix4(globeGroup.matrixWorld.invert());

                // 4. 将 3D 点转换为 经纬度
                const latLon = vector3ToLatLon(localPoint);
                
                // 5. 在 GeoJSON 数据中查找此经纬度属于哪个国家
                const country = findCountryByLatLon(latLon.lat, latLon.lon);

                updateUI(country, latLon);
                highlightCountry(country);
            } else {
                hideUI();
                clearHighlight();
                controls.autoRotate = true; // 点击星空恢复旋转
            }
        }

        function vector3ToLatLon(vector) {
            // 归一化
            vector.normalize();
            
            // 反算公式
            // y = cos(phi) => phi = acos(y) => lat = 90 - phi * 180/PI
            const lat = 90 - (Math.acos(vector.y) * 180 / Math.PI);
            
            // x = -sin(phi)cos(theta), z = sin(phi)sin(theta)
            // tan(theta) = z / -x
            // theta = atan2(z, -x) => lon = theta * 180/PI - 180
            // *注意 Three.js 的坐标系方向和 GeoJSON 可能有偏移，这里需要微调
            const lon = (Math.atan2(vector.z, -vector.x) * 180 / Math.PI) - 180;

            return { lat: lat, lon: lon };
        }

        // 点在多边形内算法 (Ray Casting / Even-Odd Rule)
        function findCountryByLatLon(lat, lon) {
            for (let feature of allCountriesData) {
                const geometry = feature.geometry;
                if (geometry.type === 'Polygon') {
                    if (isPointInPolygon(lon, lat, geometry.coordinates[0])) {
                        return feature;
                    }
                } else if (geometry.type === 'MultiPolygon') {
                    for (let polygon of geometry.coordinates) {
                        if (isPointInPolygon(lon, lat, polygon[0])) {
                            return feature;
                        }
                    }
                }
            }
            return null;
        }

        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // --- 高亮与 UI ---

        function highlightCountry(countryFeature) {
            clearHighlight();
            if (!countryFeature) return;

            // 创建一个新的高亮 Mesh
            const highlightMat = new THREE.LineBasicMaterial({ 
                color: 0xffaa00, 
                linewidth: 2,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });

            const geometryData = countryFeature.geometry;
            const pointsGroups = [];

            if (geometryData.type === 'Polygon') {
                pointsGroups.push(geometryData.coordinates[0]);
            } else if (geometryData.type === 'MultiPolygon') {
                geometryData.coordinates.forEach(poly => pointsGroups.push(poly[0]));
            }

            pointsGroups.forEach(coords => {
                const points = [];
                coords.forEach(c => {
                    // 稍微抬高一点半径，避免Z-fighting闪烁
                    points.push(latLonToVector3(c[1], c[0], EARTH_RADIUS * 1.005));
                });
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geo, highlightMat);
                globeGroup.add(line);
                highlightedObj = line; // 暂存引用以便清除
                
                // 只是存最后一个引用并不完美，但在MultiPolygon情况下
                // 为简化代码，我们把它们加到一个临时Group里会更好，
                // 这里简单处理：如果产生多个Mesh，下次clear时可能漏掉，
                // 更好的做法是用一个 highlightGroup。
                if(!window.hlGroup) {
                    window.hlGroup = new THREE.Group();
                    globeGroup.add(window.hlGroup);
                }
                window.hlGroup.add(line);
            });
        }

        function clearHighlight() {
            if (window.hlGroup) {
                window.hlGroup.clear();
            }
        }

        function updateUI(country, latLon) {
            const panel = document.getElementById('info-panel');
            const nameEl = document.getElementById('country-name');
            const coordsEl = document.getElementById('coords-display');

            if (country) {
                panel.classList.add('active');
                nameEl.innerText = country.properties.NAME || country.properties.name || "Unknown Region";
                nameEl.style.color = "#ffaa00";
            } else {
                // 点击了海洋
                panel.classList.add('active');
                nameEl.innerText = "Ocean / Intl. Waters";
                nameEl.style.color = "#00aaff";
                clearHighlight();
            }
            
            coordsEl.innerText = `LAT: ${latLon.lat.toFixed(2)} | LON: ${latLon.lon.toFixed(2)}`;
        }

        function hideUI() {
            document.getElementById('info-panel').classList.remove('active');
        }
        
        function resetView() {
            controls.reset();
            controls.autoRotate = true;
            hideUI();
            clearHighlight();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>